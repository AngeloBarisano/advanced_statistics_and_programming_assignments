---
title: "assignment_1_angelo_barisano"
output: html_document
date: '2022-09-08'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown


Please note: I have used an autoformatter which I built years ago

```{r import data & set wkdir}
# clear environment
rm(list=ls())

# import the necessary libraries
library("tidyverse")
library("stargazer")
library("tidyverse")
library("reshape")
library("Hmisc")
library("ggplot2")
library("dplyr")
library("moments")



setwd("/home/angelo/Documents/Uni/Courses/Advanced Statistics and programming/Assignments/assignment1")

df <- read.csv("Data/train.csv", header= TRUE, sep= ",")

```

```{r Initial data inspection}
# View(df)
# str(df)
```


```{r fix dtype}
# # this is a saveguard as integer operation wont work on this column if i make a mistake
# df$Id <- as.character(df$Id)
# 
# # MSSubClass is a CLASS of buildings
# df$MSSubClass <- as.factor(df$MSSubClass)
# df$MSZoning <- as.factor(df$MSZoning)
# df$Street <- as.factor(df$Street)
# df$Alley <- as.factor(df$Alley)
# df$LotShape <- as.factor(df$LotShape)
# df$LandContour <- as.factor(df$LandContour)
# df$Utilities <- as.factor(df$Utilities)
# df$LotConfig <- as.factor(df$LotConfig)
# df$LandSlope <- as.factor(df$LandSlope)
# df$Neighborhood <- as.factor(df$Neighborhood)
# df$Condition1 <- as.factor(df$Condition1)
# df$Condition2 <- as.factor(df$Condition2)
# df$BldgType <- as.factor(df$BldgType)
# df$HouseStyle <- as.factor(df$HouseStyle)
# 
# # question: is overall quality (OverallCond and OverallQual)interval of ordinal?
# # df$OverallQual <- as.factor(df$OverallQual)
# # df$HouseStyle <- as.factor(df$OverallCond)
# 
# # years built is an ordinal/ or nominal variable; so I will put into a factor
# #NOTE: YEAR and timesince can function as a variable here! conidering the YearRemodAdd (remodel date)
# df$YearBuilt <- as.factor(df$YearBuilt)
# df$YearRemodAdd <- as.factor(df$YearRemodAdd)
# 
# df$RoofStyle <- as.factor(df$RoofStyle)
# df$RoofMatl <- as.factor(df$RoofMatl)
# df$Exterior1st <- as.factor(df$Exterior1st)
# df$Exterior2nd <- as.factor(df$Exterior2nd)
# df$MasVnrType <- as.factor(df$MasVnrType)
# df$ExterQual <- as.factor(df$ExterQual)
# df$ExterCond <- as.factor(df$ExterCond)
# df$Foundation <- as.factor(df$Foundation)
# df$ExterCond <- as.factor(df$ExterCond)
# df$Foundation <- as.factor(df$Foundation)
# df$BsmtQual <- as.factor(df$BsmtQual)
# df$BsmtCond <- as.factor(df$BsmtCond)
# df$BsmtExposure <- as.factor(df$BsmtExposure)
# df$BsmtFinType1 <- as.factor(df$BsmtFinType1)
# df$BsmtFinType2 <- as.factor(df$BsmtFinType2)
# 
# df$Heating <- as.factor(df$Heating)
# df$HeatingQC <- as.factor(df$HeatingQC)
# df$CentralAir <- as.factor(df$CentralAir)
# df$KitchenQual <- as.factor(df$KitchenQual)
# df$Functional <- as.factor(df$Functional)
# df$FireplaceQu <- as.factor(df$FireplaceQu)
# df$GarageType <- as.factor(df$GarageType)
# df$GarageYrBlt <- as.factor(df$GarageYrBlt)
# df$GarageFinish <- as.factor(df$GarageFinish)
# 
# # GARAGE TYPE MAY BE A GOOD VARIABLE AS THE SIZE MEANS MORE CARS AND MORE CARS MEANS RICHER PEOPLE!!!
# df$GarageCars <- as.factor(df$GarageCars)
# 
# df$GarageQual <- as.factor(df$GarageQual)
# df$GarageCond <- as.factor(df$GarageCond)
# df$PavedDrive <- as.factor(df$PavedDrive)
# df$PoolQC <- as.factor(df$PoolQC)
# 
# 
# df$Fence <- as.factor(df$Fence)
# df$MiscFeature <- as.character(df$MiscFeature)
# 
# 
# 
# # IMPORTANT FEATURES
# # put month as factor; convert it properly to character type
# df$MoSold <- as.factor(df$MoSold)
# df$YrSold <- as.factor(df$YrSold)
# 
# # this one is interesting
# df$SaleType <- as.factor(df$SaleType)
# # this one just to make it clear
# df$SalePrice <- as.integer(df$SalePrice)


```





``` {r select variables for analysis}







```


 
 
 
 
 

```{r missing values inspection}
# display missing values by column
colSums(is.na(df))

# select all columns which have missing data 
which(colSums(is.na(df))>0)

```





# 1 Collect and prepare data

```{r Produce summarystatistics using stargazer}

# first only select the variables that I pointed out in the first part
df_ <- df[, c(
  'Id',
  'SalePrice',
  'MoSold',
  'YrSold',
  'YearBuilt',
  'YearRemodAdd',
  'LotArea',
  'GrLivArea',
  'TotalBsmtSF',
  'BedroomAbvGr',
  'BsmtFullBath',
  'FullBath',
  # garage cars may not be relevant!!
  'PoolArea', 
  'Condition1',
  'Condition2',
  'GarageCars',
  'BldgType',
  'MSZoning',
  'Neighborhood',
  'OverallQual',
  'OverallCond',
  'LotShape'
)]

# create the interesting varaibles
df_$tot_living_area <- df_$GrLivArea + df_$TotalBsmtSF
df_$tot_bathrooms <- df_$BsmtFullBath + df_$FullBath

# resample Condition1 and Condition2 into categories of variables 
match_df = data.frame(
  old = c("Artery", "Feedr", "Norm", "PosA", "PosN", "RRAe", "RRAn", "RRNe", "RRNn"),
  new = c(
    'Good Street Access',
    'Good Street Access',
    'Normal',
    'Close to Recreation',
    'Close to Recreation',
    'Adjacent to Railroad',
    'Adjacent to Railroad',
    'Adjacent to Railroad',
    'Adjacent to Railroad'
  )
)

df_ <- df_ %>% mutate(Adjacent_features = match_df$new[match(Condition1,match_df$old)])
df_$Adjacent_features <- as.factor(df_$Adjacent_features)


# and now, in much simpler: if an advantage is adjacent, then True, if normal False

match_df = data.frame(
  old = c("Artery", "Feedr", "Norm", "PosA", "PosN", "RRAe", "RRAn", "RRNe", "RRNn"),
  new = c(
    TRUE,
    TRUE,
    FALSE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE
  )
)

df_ <- df_ %>% mutate(Adjacent_features_bool = match_df$new[match(Condition1,match_df$old)])


# create a variable of pool true of false:
df_$PoolArea[df_$PoolArea != 0] <- TRUE
df_$PoolArea[df_$PoolArea == 0] <- FALSE




# adjust for family homes
# the distinction made here is simply that:
# stand alone house vs multiple houses together
match_df = data.frame(
  old = c("1Fam", "2fmCon", "Duplex",  "Twnhs", "TwnhsE" ),
  new = c(
    "Single Family Home",
    "Multiple Combined Units",
    "Multiple Combined Units",
    "Multiple Combined Units",
    "Multiple Combined Units"
  )
)

df_ <- df_ %>% mutate(Building_type = match_df$new[match(BldgType,match_df$old)])



# group irregular lothspaes
match_df = data.frame(
  old = c("IR1", "IR2", "IR3",  "Reg"),
  new = c(
    "Irregular",
    "Irregular",
    "Irregular",
    "Regular"
  )
)

df_ <- df_ %>% mutate(LotShape = match_df$new[match(LotShape,match_df$old)])


# group zoning 
match_df = data.frame(
  old = c("C (all)","FV","RH","RL","RM" ),
  new = c(
    "Commercial",
    "Floating Village",
    "Moderate-High Density",
    "Low Density",
    "Moderate-High Density"
  )
)

df_ <- df_ %>% mutate(MSZoning_grouped = match_df$new[match(MSZoning,match_df$old)])


table(df_$MSZoning_grouped)
```



```{r inspect dypes of the variables at hand}
# to make it clear that only certain operations can be performed on the data
df_$Id <- as.factor(df_$Id)
df_$MoSold <- as.factor(df_$MoSold)
df_$YrSold <- as.factor(df_$YrSold)

df_$Neighborhood <- as.factor(df_$Neighborhood)
df_$BldgType <- as.factor(df_$BldgType)
df_$MSZoning <- as.factor(df_$MSZoning)

# poolarea is pointless as only few people have a pool
df_$PoolArea <- as.logical(df_$PoolArea)

```




```{r inspect missing values}
# display missing values by column
colSums(is.na(df_))


# select all columns which have missing data 
which(colSums(is.na(df_))>0)

```







```{r stargazer output and summary statistics}
df_temp <- df_ %>%
  select(-one_of(c('Id')))
skewness(df_temp$SalePrice)

stargazer(df_temp)
```


```{r categorical variable prelim analyiss}
# df$MSZoning
# table(df$Neighborhood)
# table(df$MSZoning)
# 
# table1 <- table(table(df$Neighborhood, df$MSZoning))
# stargazer(ftable(table1))
# 
# table(df$MSZoning, df$Neighborhood)
# table(df$BldgType)
```


```{r plots, echo=FALSE}
# scaplom

df_temp <- df_ %>%
  select(-one_of(
    c(
      'Id',
      'MoSold',
      'YrSold',
      'BldgType',
      'MSZoning',
      'Neighborhood'
    )
  ))
# pairs(df_temp, pch = 19)

```

```{r }

# first plot:
# sales price with respect to size of the living area conditional on the ZONING!
scatter <- ggplot(df_, aes(tot_living_area, SalePrice))
scatter + geom_point() + geom_smooth(method = "lm", color = "Red") + labs(x = 'Living space in square feet', y = "Sale Price")+ xlim(0, 7000)


# HYPOTHESIS: total living area impact on price! 

```



```{r plots, echo=FALSE}



# SalePrice, tot_living_area,
df_subset <- subset(df_, MSZoning != "C (all)")

# now drill down
scatter <-
  ggplot(df_subset, aes(tot_living_area, SalePrice, colour = MSZoning))
scatter + geom_point() + geom_smooth(method = "lm", aes(fill = "MSZoning"), alpha = 0.1) + labs(x = 'Living space in square feet', y = "Sale Price", color = 'MSZoning')



#' the first thing to note is that there are quite some extreme outliers in terms of living space



#' then try to set the focus on the xlim to control for the outliers
scatter <-
  ggplot(df_subset, aes(tot_living_area, SalePrice, colour = MSZoning))
scatter + geom_point() + geom_smooth(method = "lm", aes(fill = "MSZoning"), alpha = 0.1) + labs(x = 'Living space in square feet', y = "Sale Price", color = 'MSZoning') + xlim(0, 7000)


#' Finally, only consider the two most important features: RL (Low density) and RM (Moderate density)
df_subset <- subset(df_, MSZoning == "RM" | MSZoning == "RL")
scatter <-
  ggplot(df_subset, aes(tot_living_area, SalePrice, colour = MSZoning))
scatter + geom_point() + geom_smooth(method = "lm", aes(fill = "MSZoning"), alpha = 0.1) + labs(x = 'Living space in square feet', y = "Sale Price", color = 'MSZoning') + xlim(0, 7000)


#' as we expected, rurak areas (Low density) correspond with a larger size
#' however, have is interesting in this equation is that the low density region
#' tends to be sold higher than that of moderately dense
bar <- ggplot(df_, aes(MSZoning, SalePrice))

bar + stat_summary(
  fun = mean,
  geom = "bar",
  fill = 'white',
  colour = "Black"
) + stat_summary(fun.data = mean_cl_normal, geom = "pointrange") + labs(x = 'Zoning', y = 'Sale Price')

#' these findings are supported by the corresponding barcharts; certain zonings correspond with higher sales price
bar <- ggplot(df_subset, aes(MSZoning, SalePrice))

bar + stat_summary(
  fun = mean,
  geom = "bar",
  fill = 'white',
  colour = "Black"
) + stat_summary(fun.data = mean_cl_normal, geom = "pointrange") + labs(x = 'Zoning', y = 'Sale Price')

# HYPOTHESIS: Zoning matters
# Possibly group High and moderately populated areas together
table(df_$MSZoning_grouped)

df_subset <-
  subset(df_,
         MSZoning_grouped == "Moderate-High Density" |
           MSZoning_grouped == "Low Density")
scatter <-
  ggplot(df_subset,
         aes(tot_living_area, SalePrice, colour = MSZoning_grouped))
scatter + geom_point() + geom_smooth(method = "lm", aes(fill = "MSZoning_grouped"), alpha = 0.1) + labs(x = 'Living space in square feet', y = "Sale Price", color = 'MSZoning_grouped') + xlim(0, 7000)





```
```{r plots, echo=FALSE}
table(df_$MSZoning)
```


```{r plots, echo=FALSE}
# Second plots:
# living space and sales price wrt Neighborhood 

scatter <- ggplot(df_, aes(tot_living_area, SalePrice))
scatter + geom_point() + geom_smooth(method = "lm", color = "Red") + labs(x = 'Living space in square feet', y = "Sale Price")


scatter <- ggplot(df_, aes(tot_living_area, SalePrice, colour = Neighborhood))
scatter + geom_point() + geom_smooth(method = "lm", aes(fill = "Neighborhood"), alpha = 0.1) + labs(x = 'Living space in square feet', y = "Sale Price", color = 'Neighborhood')


scatter <- ggplot(df_, aes(tot_living_area, SalePrice))
scatter + geom_point() + geom_smooth(method = "lm", color = "Red") + labs(x = 'Living space in square feet', y = "Sale Price") + xlim(0, 7000)


scatter <- ggplot(df_, aes(tot_living_area, SalePrice, colour = Neighborhood))
scatter + geom_point() + geom_smooth(method = "lm", aes(fill = "Neighborhood"), alpha = 0.1) + labs(x = 'Living space in square feet', y = "Sale Price", color = 'Neighborhood') + xlim(0, 7000)

df_subset <-
  subset(
    df_,
    Neighborhood == "NoRidge" |
      Neighborhood == "OldTown" |
      Neighborhood == "CollgCr" |
      Neighborhood == "NridgHt" 
  )

scatter <- ggplot(df_subset, aes(tot_living_area, SalePrice))
scatter + geom_point() + geom_smooth(method = "lm", color = "Red") + labs(x = 'Living space in square feet', y = "Sale Price") + xlim(0, 7000)


scatter <- ggplot(df_subset, aes(tot_living_area, SalePrice, colour = Neighborhood))
scatter + geom_point() + geom_smooth(method = "lm", aes(fill = "Neighborhood"), alpha = 0.1) + labs(x = 'Living space in square feet', y = "Sale Price", color = 'Neighborhood') + xlim(0, 7000)


```




```{r plots, echo=FALSE}
# condition is not important in comparison with quality of the house !!!!  
# HYPOTHESIS: Condition is unimportant (compared to quality of the house)

scatter <- ggplot(df_, aes(OverallCond, SalePrice))
scatter + geom_point() + geom_smooth(method = "lm", color = "Red") + labs(x = 'Condition of the property', y = "Sale Price")


df_subset <-
  subset(
    df_,
    Neighborhood == "NoRidge" |
      Neighborhood == "OldTown" |
      Neighborhood == "CollgCr" |
      Neighborhood == "NridgHt" 
  )

scatter <- ggplot(df_subset, aes(OverallCond, SalePrice))
scatter + geom_point() + geom_smooth(method = "lm", color = "Red") + labs(x = 'Condition of the property', y = "Sale Price")


scatter <- ggplot(df_subset, aes(OverallCond, SalePrice, colour = Neighborhood))
scatter + geom_point() + geom_smooth(method = "lm", aes(fill = "Neighborhood"), alpha = 0.1) + labs(x = 'Condition of the property', y = "Sale Price", color = 'Neighborhood')

#' rsulting from this observation one hypothesis might be that neighborhood does not moderate the 
#' association between condition and sales price 

```
```{r plots, echo=FALSE}

# HYPOTHESIS: Quality and SALES + Neighborhood clusters

# Quality, sales and neighborhood havign a rumble 

scatter <- ggplot(df_, aes(OverallQual, SalePrice))
scatter + geom_point() + geom_smooth(method = "lm", color = "Red") + labs(x = 'Quality of the property', y = "Sale Price")


scatter <- ggplot(df_, aes(OverallQual, SalePrice, colour = Neighborhood))
scatter + geom_point() + geom_smooth(method = "lm", aes(fill = "Neighborhood"), alpha = 0.1) + labs(x = 'Quality of the property', y = "Sale Price", color = 'Neighborhood')



#
#' THe interesting observation here is that not only does the quality of houses and the sale price show a positive (not completely linear -- rather quadratic)associtiation; but also do the neighborhoods tend to cluster. Thus, this suggests that there are well-off neighborhoods and worse 
#' off neighborhoods #'suggesting that neighborhoods are an important factor in this equation.

# now select only a few neighborhoods as comparison top drive home the point of clsuters in the data
df_subset <-
  subset(
    df_,
    Neighborhood == "NoRidge" |
      Neighborhood == "OldTown" |
      Neighborhood == "CollgCr" |
      Neighborhood == "NridgHt" 
  )



scatter <-
  ggplot(df_subset, aes(OverallQual, SalePrice, colour = Neighborhood))

scatter + geom_point() + geom_smooth(method = "lm",
                                     aes(fill = "Neighborhood"),
                                     alpha = 0.1) + labs(x = 'Quality of the property', y = "Sale Price", color = 'Neighborhood')
#' as can be seen, not only does quality of the property  have a positive association with sale price
#' but also so does neighborhood (afluent neighborhoods) suggesting clusters in the data!
```
```{r plots, echo=FALSE}
# Adjacent_features_bool


#' plot some showing the distribution of arousal by film
bar <- ggplot(df_, aes(Condition1, SalePrice))

bar + stat_summary(
  fun = mean,
  geom = "bar",
  fill = 'white',
  colour = "Black"
) + stat_summary(fun.data = mean_cl_normal, geom = "pointrange") + labs(x = 'Adjacent Features', y = 'Sale Price')

bar <- ggplot(df_, aes(Adjacent_features_bool, SalePrice))

bar + stat_summary(
  fun = mean,
  geom = "bar",
  fill = 'white',
  colour = "Black"
) + stat_summary(fun.data = mean_cl_normal, geom = "pointrange") + labs(x = 'Has Adjacent Features', y = 'Sale Price')

bar <- ggplot(df_, aes(Adjacent_features, SalePrice))

bar + stat_summary(
  fun = mean,
  geom = "bar",
  fill = 'white',
  colour = "Black"
) + stat_summary(fun.data = mean_cl_normal, geom = "pointrange") + labs(x = 'Adjacent Features Grouped', y = 'Sale Price')

#' sadly the sample size for recreation is too low even when combined iwth Condition2
#' so we disregard this angle
table(df_$Adjacent_features_bool)
```







```{r plots, echo=FALSE}
# Final hypothesis: the effect of total living space on sales price is determined by the zoning
# MAYBE TRY BUILDING TYPE!!


scatter <- ggplot(df_, aes(tot_living_area, SalePrice))
scatter + geom_point() + geom_smooth(method = "lm", color = "Red") + labs(x = 'Living space in square feet', y = "Sale Price") + xlim(0, 7000)
 
scatter <- ggplot(df_, aes(tot_living_area, SalePrice, colour = Building_type))
scatter + geom_point() + geom_smooth(method = "lm", aes(fill = "Building_type"), alpha = 0.1) + labs(x = 'Living space in square feet', y = "Sale Price", color = 'Building_type')


scatter <- ggplot(df_, aes(tot_living_area, SalePrice, colour = Building_type))
scatter + geom_point() + geom_smooth(method = "lm", aes(fill = "Building_type"), alpha = 0.1) + labs(x = 'Living space in square feet', y = "Sale Price", color = 'Building_type') 

# maybe: the difference in buildign type prices can be explained by the itneraction with size; one family
# homes tend to be larger to begin with for instance

# table(df_$Building_type)
```
```{r final attempt at plot: TWO numeric Independent variables}
# Homesize to sale price by lotshape (awkward lotshape may mean smaller houses only possible)


scatter <- ggplot(df_, aes(tot_living_area, SalePrice, colour = LotShape))
scatter + geom_point() + geom_smooth(method = "lm", aes(fill = "Building_type"), alpha = 0.1) + labs(x = 'Living space in square feet', y = "Sale Price", color = 'Lot Shape') + xlim(0, 7000)


#' lotshpae has no interesting outcome here:
#' so the hypothesis to be tested would be: an irregular lotshape does not impact the relationship of livingarea to saleprice


#' make a brplot here 
bar <- ggplot(df_, aes(LotShape, SalePrice))

bar + stat_summary(
  fun = mean,
  geom = "bar",
  fill = 'white',
  colour = "Black"
) + stat_summary(fun.data = mean_cl_normal, geom = "pointrange") + labs(x = 'LotShape', y = 'Sale Price')
#' even though irregular lot sizes show a higher average sales price; this seems not to be of a causal nature; as such this question is not worth to be investigated.

```


```{r final attempt at plot: TWO numeric Independent variables}
# Lotsize, tot_living_area, SalePrice

ggplot(df_, aes(x = tot_living_area, y = SalePrice)) +
  geom_point(aes(size = LotArea), alpha = 0.5) +
  scale_color_manual(values = c("#AA4371", "#E7B800", "#FC4E07")) +
  scale_size(range = c(1, 13)) + # Adjust the range of points size
  theme_set(theme_bw() +theme(legend.position = "bottom"))+ xlim(0, 7000)



ggplot(df_, aes(x = LotArea, y = SalePrice)) +
  geom_point(aes(size = tot_living_area), alpha = 0.5) +
  scale_color_manual(values = c("#AA4371", "#E7B800", "#FC4E07")) +
  scale_size(range = c(1, 13)) + # Adjust the range of points size
  theme_set(theme_bw() +theme(legend.position = "bottom"))+ xlim(0, 7000)

#' Either way, no clear association can be discerned; so we leave this trajectory
```


```{r final attempt at plot: TWO numeric Independent variables}
# LotArea, tot_living_area, SalePrice

ggplot(df_, aes(x = tot_living_area, y = SalePrice)) +
  geom_point(aes(color = Adjacent_features_bool, size = LotArea), alpha = 0.5) +
  scale_color_manual(values = c("#AA4371", "#E7B800", "#FC4E07")) +
  scale_size(range = c(1, 13)) + # Adjust the range of points size
  theme_set(theme_bw() +theme(legend.position = "bottom")) + xlim(0, 7000)

#' pointless
```












NOTE: It my be interesting to know whether Neighborhoods all fall into the same Zoning
