---
title: "assignment_1_angelo_barisano"
output: html_document
date: '2022-09-08'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown


Please note: I have used an autoformatter which I built years ago

```{r import data & set wkdir}
# clear environment
rm(list=ls())

# import the necessary libraries
library("tidyverse")
library("stargazer")
library("tidyverse")
library("reshape")
library("Hmisc")
library("ggplot2")
library("dplyr")
library("moments")



setwd("/home/angelo/Documents/Uni/Courses/Advanced Statistics and programming/Assignments/assignment1")

df <- read.csv("Data/train.csv", header= TRUE, sep= ",")

```

```{r Initial data inspection}
# View(df)
# str(df)
```


```{r fix dtype}
# # this is a saveguard as integer operation wont work on this column if i make a mistake
# df$Id <- as.character(df$Id)
# 
# # MSSubClass is a CLASS of buildings
# df$MSSubClass <- as.factor(df$MSSubClass)
# df$MSZoning <- as.factor(df$MSZoning)
# df$Street <- as.factor(df$Street)
# df$Alley <- as.factor(df$Alley)
# df$LotShape <- as.factor(df$LotShape)
# df$LandContour <- as.factor(df$LandContour)
# df$Utilities <- as.factor(df$Utilities)
# df$LotConfig <- as.factor(df$LotConfig)
# df$LandSlope <- as.factor(df$LandSlope)
# df$Neighborhood <- as.factor(df$Neighborhood)
# df$Condition1 <- as.factor(df$Condition1)
# df$Condition2 <- as.factor(df$Condition2)
# df$BldgType <- as.factor(df$BldgType)
# df$HouseStyle <- as.factor(df$HouseStyle)
# 
# # question: is overall quality (OverallCond and OverallQual)interval of ordinal?
# # df$OverallQual <- as.factor(df$OverallQual)
# # df$HouseStyle <- as.factor(df$OverallCond)
# 
# # years built is an ordinal/ or nominal variable; so I will put into a factor
# #NOTE: YEAR and timesince can function as a variable here! conidering the YearRemodAdd (remodel date)
# df$YearBuilt <- as.factor(df$YearBuilt)
# df$YearRemodAdd <- as.factor(df$YearRemodAdd)
# 
# df$RoofStyle <- as.factor(df$RoofStyle)
# df$RoofMatl <- as.factor(df$RoofMatl)
# df$Exterior1st <- as.factor(df$Exterior1st)
# df$Exterior2nd <- as.factor(df$Exterior2nd)
# df$MasVnrType <- as.factor(df$MasVnrType)
# df$ExterQual <- as.factor(df$ExterQual)
# df$ExterCond <- as.factor(df$ExterCond)
# df$Foundation <- as.factor(df$Foundation)
# df$ExterCond <- as.factor(df$ExterCond)
# df$Foundation <- as.factor(df$Foundation)
# df$BsmtQual <- as.factor(df$BsmtQual)
# df$BsmtCond <- as.factor(df$BsmtCond)
# df$BsmtExposure <- as.factor(df$BsmtExposure)
# df$BsmtFinType1 <- as.factor(df$BsmtFinType1)
# df$BsmtFinType2 <- as.factor(df$BsmtFinType2)
# 
# df$Heating <- as.factor(df$Heating)
# df$HeatingQC <- as.factor(df$HeatingQC)
# df$CentralAir <- as.factor(df$CentralAir)
# df$KitchenQual <- as.factor(df$KitchenQual)
# df$Functional <- as.factor(df$Functional)
# df$FireplaceQu <- as.factor(df$FireplaceQu)
# df$GarageType <- as.factor(df$GarageType)
# df$GarageYrBlt <- as.factor(df$GarageYrBlt)
# df$GarageFinish <- as.factor(df$GarageFinish)
# 
# # GARAGE TYPE MAY BE A GOOD VARIABLE AS THE SIZE MEANS MORE CARS AND MORE CARS MEANS RICHER PEOPLE!!!
# df$GarageCars <- as.factor(df$GarageCars)
# 
# df$GarageQual <- as.factor(df$GarageQual)
# df$GarageCond <- as.factor(df$GarageCond)
# df$PavedDrive <- as.factor(df$PavedDrive)
# df$PoolQC <- as.factor(df$PoolQC)
# 
# 
# df$Fence <- as.factor(df$Fence)
# df$MiscFeature <- as.character(df$MiscFeature)
# 
# 
# 
# # IMPORTANT FEATURES
# # put month as factor; convert it properly to character type
# df$MoSold <- as.factor(df$MoSold)
# df$YrSold <- as.factor(df$YrSold)
# 
# # this one is interesting
# df$SaleType <- as.factor(df$SaleType)
# # this one just to make it clear
# df$SalePrice <- as.integer(df$SalePrice)


```





``` {r select variables for analysis}







```


 
 
 
 
 

```{r missing values inspection}
# display missing values by column
colSums(is.na(df))

# select all columns which have missing data 
which(colSums(is.na(df))>0)

```




```{r Data cleaning and imputation}
# Missing Value Treatment
for(i in c(1:78))
{
  if(class(train[,i])=="factor")
  {
    train[is.na(train[,i]),i]<-names(which.max(table(train[,i])))
  }else{
    train[is.na(train[,i]),i]<-median(unlist(train[,i]),na.rm = TRUE)
  }
}

```

Condition1: Proximity to various conditions
	
       Artery	Adjacent to arterial street
       Feedr	Adjacent to feeder street	
       Norm	Normal	
       RRNn	Within 200' of North-South Railroad
       RRAn	Adjacent to North-South Railroad
       PosN	Near positive off-site feature--park, greenbelt, etc.
       PosA	Adjacent to postive off-site feature
       RRNe	Within 200' of East-West Railroad
       RRAe	Adjacent to East-West Railroad
	
Condition2: Proximity to various conditions (if more than one is present)
--> PUt condition based on general categories: Such as proximity to important streets, adjacedn to railroats, near park/ nature, normal (4 categories to be remodeled)


Then: pool yes no: PoolArea



# 1 Collect and prepare data

```{r Produce summarystatistics using stargazer}

# first only select the variables that I pointed out in the first part
df_ <- df[, c(
  'Id',
  'SalePrice',
  'MoSold',
  'YrSold',
  'YearBuilt',
  'YearRemodAdd',
  'LotArea',
  'GrLivArea',
  'TotalBsmtSF',
  'BedroomAbvGr',
  'BsmtFullBath',
  'FullBath',
  # garage cars may not be relevant!!
  'PoolArea', 
  'Condition1',
  'Condition2',
  'GarageCars',
  'BldgType',
  'MSZoning',
  'Neighborhood',
  'OverallQual',
  'OverallCond',
  'LotShape'
)]

# create the interesting varaibles
df_$tot_living_area <- df_$GrLivArea + df_$TotalBsmtSF
df_$tot_bathrooms <- df_$BsmtFullBath + df_$FullBath

# resample Condition1 and Condition2 into categories of variables 
match_df = data.frame(
  old = c("Artery", "Feedr", "Norm", "PosA", "PosN", "RRAe", "RRAn", "RRNe", "RRNn"),
  new = c(
    'Good Street Access',
    'Good Street Access',
    'Normal',
    'Close to Recreation',
    'Close to Recreation',
    'Adjacent to Railroad',
    'Adjacent to Railroad',
    'Adjacent to Railroad',
    'Adjacent to Railroad'
  )
)

df_ <- df_ %>% mutate(Adjacent_features = match_df$new[match(Condition1,match_df$old)])
df_$Adjacent_features <- as.factor(df_$Adjacent_features)


# and now, in much simpler: if an advantage is adjacent, then True, if normal False

match_df = data.frame(
  old = c("Artery", "Feedr", "Norm", "PosA", "PosN", "RRAe", "RRAn", "RRNe", "RRNn"),
  new = c(
    TRUE,
    TRUE,
    FALSE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE
  )
)

df_ <- df_ %>% mutate(Adjacent_features_bool = match_df$new[match(Condition1,match_df$old)])


# create a variable of pool true of false:
df_$PoolArea[df_$PoolArea != 0] <- TRUE
df_$PoolArea[df_$PoolArea == 0] <- FALSE

```




```{r inspect dypes of the variables at hand}


# to make it clear that only certain operations can be performed on the data
df_$Id <- as.factor(df_$Id)
df_$MoSold <- as.factor(df_$MoSold)
df_$YrSold <- as.factor(df_$YrSold)

df_$Neighborhood <- as.factor(df_$Neighborhood)
df_$BldgType <- as.factor(df_$BldgType)
df_$MSZoning <- as.factor(df_$MSZoning)

# poolarea is pointless as only few people have a pool
df_$PoolArea <- as.logical(df_$PoolArea)

```




```{r inspect missing values}
# display missing values by column
colSums(is.na(df_))


# select all columns which have missing data 
which(colSums(is.na(df_))>0)

```







```{r stargazer output and summary statistics}
df_temp <- df_ %>%
  select(-one_of(c('Id')))
skewness(df_temp$SalePrice)

stargazer(df_temp, type = 'text')
```


```{r categorical variable prelim analyiss}
df$MSZoning
table(df$Neighborhood)
table(df$MSZoning)

table1 <- table(table(df$Neighborhood, df$MSZoning))
stargazer(ftable(table1))

table(df$MSZoning, df$Neighborhood)
table(df$BldgType)
```
```{r plots, echo=FALSE}
View(df_)

# scaplom

df_temp <- df_ %>%
  select(-one_of(
    c(
      'Id',
      'MoSold',
      'YrSold',
      'BldgType',
      'MSZoning',
      'Neighborhood'
    )
  ))
pairs(df_temp, pch = 19)

```



```{r }

# first plot:
# sales price with respect to size of the living area conditional on the ZONING!
scatter <- ggplot(df_, aes(tot_living_area, SalePrice))
scatter + geom_point() + geom_smooth(method = "lm", color = "Red") + labs(x = 'Living space in square feet', y = "Sale Price")+ xlim(0, 7000)


# HYPOTHESIS: total living area impact on price! 

```




```{r plots, echo=FALSE}


# SalePrice, tot_living_area, 
df_subset <- subset(df_, MSZoning != "C (all)")  
  
# now drill down
scatter <- ggplot(df_subset, aes(tot_living_area, SalePrice, colour = MSZoning))
scatter + geom_point() + geom_smooth(method = "lm", aes(fill = "MSZoning"), alpha = 0.1) + labs(x = 'Living space in square feet', y = "Sale Price", color = 'MSZoning')



#' the first thing to note is that there are quite some extreme outliers in terms of living space



#' then try to set the focus on the xlim to control for the outliers
scatter <- ggplot(df_subset, aes(tot_living_area, SalePrice, colour = MSZoning))
scatter + geom_point() + geom_smooth(method = "lm", aes(fill = "MSZoning"), alpha = 0.1) + labs(x = 'Living space in square feet', y = "Sale Price", color = 'MSZoning') + xlim(0, 7000)


#' Finally, only consider the two most important features: RL (Low density) and RM (Moderate density)
df_subset <- subset(df_, MSZoning == "RM" | MSZoning == "RL" )
scatter <- ggplot(df_subset, aes(tot_living_area, SalePrice, colour = MSZoning))
scatter + geom_point() + geom_smooth(method = "lm", aes(fill = "MSZoning"), alpha = 0.1) + labs(x = 'Living space in square feet', y = "Sale Price", color = 'MSZoning') + xlim(0, 7000)


#' as we expected, rurak areas (Low density) correspond with a larger size
#' however, have is interesting in this equation is that the low density region
#' tends to be sold higher than that of moderately dense
bar <- ggplot(df_, aes(MSZoning, SalePrice))

bar + stat_summary(
  fun = mean,
  geom = "bar",
  fill = 'white',
  colour = "Black"
) + stat_summary(fun.data = mean_cl_normal, geom = "pointrange") + labs(x = 'Zoning', y = 'Sale Price')

#' these findings are supported by the corresponding barcharts; certain zonings correspond with higher sales price
bar <- ggplot(df_subset, aes(MSZoning, SalePrice))

bar + stat_summary(
  fun = mean,
  geom = "bar",
  fill = 'white',
  colour = "Black"
) + stat_summary(fun.data = mean_cl_normal, geom = "pointrange") + labs(x = 'Zoning', y = 'Sale Price')

HYPOTHESIS: Zoning matters

```


```{r plots, echo=FALSE}
# Second plots:
# living space and sales price wrt Neighborhood 

scatter <- ggplot(df_, aes(tot_living_area, SalePrice))
scatter + geom_point() + geom_smooth(method = "lm", color = "Red") + labs(x = 'Living space in square feet', y = "Sale Price")


scatter <- ggplot(df_, aes(tot_living_area, SalePrice, colour = Neighborhood))
scatter + geom_point() + geom_smooth(method = "lm", aes(fill = "Neighborhood"), alpha = 0.1) + labs(x = 'Living space in square feet', y = "Sale Price", color = 'Neighborhood')





```




```{r plots, echo=FALSE}
# condition is not important in comparison with quality of the house !!!!  
HYPOTHESIS: Condition is unimportant (compared to quality of the house)
scatter <- ggplot(df_, aes(OverallCond, SalePrice))
scatter + geom_point() + geom_smooth(method = "lm", color = "Red") + labs(x = 'Condition of the property', y = "Sale Price")

```
```{r plots, echo=FALSE}

HYPOTHESIS: Quality and SALES + Neighborhood clusters
# Quality, sales and neighborhood havign a rumble 

scatter <- ggplot(df_, aes(OverallQual, SalePrice))
scatter + geom_point() + geom_smooth(method = "lm", color = "Red") + labs(x = 'Quality of the property', y = "Sale Price")


scatter <- ggplot(df_, aes(OverallQual, SalePrice, colour = Neighborhood))
scatter + geom_point() + geom_smooth(method = "lm", aes(fill = "Neighborhood"), alpha = 0.1) + labs(x = 'Quality of the property', y = "Sale Price", color = 'Neighborhood')



#
#' THe interesting observation here is that not only does the quality of houses and the sale price show a positive (not completely linear -- rather quadratic)associtiation; but also do the neighborhoods tend to cluster. Thus, this suggests that there are well-off neighborhoods and worse 
#' off neighborhoods #'suggesting that neighborhoods are an important factor in this equation.

# now select only a few neighborhoods as comparison top drive home the point of clsuters in the data
df_subset <-
  subset(
    df_,
    Neighborhood == "NoRidge" |
      Neighborhood == "OldTown" |
      Neighborhood == "CollgCr" |
      Neighborhood == "NridgHt" 
  )



scatter <-
  ggplot(df_subset, aes(OverallQual, SalePrice, colour = Neighborhood))

scatter + geom_point() + geom_smooth(method = "lm",
                                     aes(fill = "Neighborhood"),
                                     alpha = 0.1) + labs(x = 'Quality of the property', y = "Sale Price", color = 'Neighborhood')
#' as can be seen, not only does quality of the property  have a positive association with sale price
#' but also so does neighborhood (afluent neighborhoods) suggesting clusters in the data!
```
```{r plots, echo=FALSE}
# Adjacent_features_bool


#' plot some showing the distribution of arousal by film
bar <- ggplot(df_, aes(Adjacent_features, SalePrice))

bar + stat_summary(
  fun = mean,
  geom = "bar",
  fill = 'white',
  colour = "Black"
) + stat_summary(fun.data = mean_cl_normal, geom = "pointrange") + labs(x = 'Has Adrjacent Features', y = 'Sale Price')

#' sadly the sample size for recreation is too low even when combined iwth Condition2
#' so we disregard this angle

```







```{r plots, echo=FALSE}
# Final hypothesis: the effect of total living space on sales price is determined by the zoning
# MAYBE TRY BUILDING TYPE!!
scatter <- ggplot(df_, aes(tot_living_area, SalePrice))
scatter + geom_point() + geom_smooth(method = "lm", color = "Red") + labs(x = 'Quality of the property', y = "Sale Price") + xlim(0, 7000)
 
scatter <- ggplot(df_, aes(tot_living_area, SalePrice, colour = MSZoning))
scatter + geom_point() + geom_smooth(method = "lm", aes(fill = "MSZoning"), alpha = 0.1) + labs(x = 'Quality of the property', y = "Sale Price", color = 'MSZoning')


colnames(df_)
```







